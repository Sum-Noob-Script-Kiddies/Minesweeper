import pygame as pg

class Button():
    """Button with different textures when Idle, Hovered Over, or Pressed.

    In order for the button to work as intended, the following must be done in the game loop:
    - Call `mouse_check(mouse_pos)` with the mouse position every frame
    - Call `mouse_check(mouse_pos, mouse_event)` when a pg.MOUSEBUTTONUP or
      pg.MOUSEBUTTONDOWN event is received in the event handler
    """
    IDLE = 0
    HOVER = 1
    PRESSED = 2

    def __init__(self, imgs, offset=(0, 0), funcs=None, on_surface=None, surface_abs_pos=(0, 0), *, center=False):
        """Creates a Button object at `offset` on `on_surface` that executes `func` when clicked.
    
        Args:
            imgs (Tuple[pg.Surface]): Tuple of 3 surfaces - (Idle, Hover, Pressed) Hover/Pressed can be None (to auto-generate)
            offset ((int, int)): (x, y) offset from top-left of `on_surface` (x, y) will be the top-left of the button, unless `centre=True`
            funcs (function | Dict[int:function]):
                The callback function, MUST accept exactly 1 argument (the instance of the button that called it)
                Triggered by default when a button is left-clicked,
                To override / multiple functions, use a dictionary with KEY being button num, VAL being function
            on_surface (pg.Surface): The surface to render the button on (default to the game display surface)
            surface_abs_pos ((int, int)): (x, y) absolute coordinate of `on_surface`, used for calculation of mouse coordinates

            centre (bool): True to set `offset` (x, y) to mean the centre of the button (instead of top-left)
        
        Examples:
            - Create a button with top-left at (100, 100) of the screen, calls `my_func` with `self` when left-clicked
                - Provide all images as paths  
                    - `button1 = Button(("idle.png", "hover.png", "pressed.png"), (100, 100), my_func)`
                - Hover and Pressed images can be None (will be auto-generated by darkening)
                    - `button1 = Button(("idle.png", None, "pressed.png"), (100, 100), my_func)`
                - If only Idle image provided, can pass without a Tuple
                    - `button1 = Button("idle.png", (100, 100), my_func)`
                - Pygame Surfaces can be passed directly instead of paths
                    - `button1 = Button((surface1, surface2, surface3), (100, 100), my_func)`

            - Create a button with it's centre at (100, 100)
                - `button1 = Button("idle.png", (100, 100), my_func, center=True)`

            - Button that runs `func_L(self)` when left-clicked and `func_R(self)` when right-clicked
                - `button1 = Button("idle.png", (100, 100), {1: func_L, 3: func_R})`
        """

        # Initialise imgs
        if isinstance(imgs, str):
            imgs = (imgs,)
        try:    # Create an Tuple if surfaces not given in a Tuple
            iter(imgs)
        except TypeError:
            imgs = (imgs,)

        self.imgs = [None, None, None]
        try:
            for i, img in enumerate(imgs):
                if isinstance(img, str):    # User provided a path instead of surface
                    img = pg.image.load(img).convert_alpha()
                elif not (isinstance(img, pg.Surface) or img is None):
                    raise Exception("Button img not a pg.Surface or Path (str)")
                self.imgs[i] = img
        except IndexError:
            raise Exception("Too many images, only (Idle, Hover, Pressed)")
        # We have self.imgs containing [Surface/None, Surface/None, Surface/None]
        
        self.imgs = self.fill_none_imgs(self.imgs)
        # We have self.imgs containing [Surface, Surface, Surface]

        # If no on_surface specified, we will default to the button being blitted onto the game screen
        if on_surface is None:
            on_surface = pg.display.get_surface()
        self.on_surface = on_surface
        self._on_surface_rect = on_surface.get_rect()
        self.surface_abs_pos = surface_abs_pos
        
        if center:
            self.rect = self.imgs[self.IDLE].get_rect(center=offset)
        else:
            self.rect = self.imgs[self.IDLE].get_rect(topleft=offset)

        # Initialise funcs
        if funcs is None:   # If no trigger specified, "Clicked <button>" function will be assigned
            funcs = lambda x: print("Clicked", x)
        if callable(funcs): # Create the function dictionary if only given a function (more specifically a callable)
            funcs = {1: funcs}  # Defaults to a left-click triggered button
        elif not isinstance(funcs, dict):   # Error check
            raise TypeError("funcs not a function or dictionary of functions!")
        assert all(isinstance(k, int) for k in funcs), "Dictionary keys should be int mouse buttons"
        self.funcs = funcs

        self.await_release = None   # The button that is currently awaiting release
        self._img_ind = self.IDLE   # The button's image state is based on this

    def mouse_check(self, abs_pos, event=None):
        """Updates button status based on mouse
        
        Called with just mouse position to check for hovering
        Can also be called with a MOUSEBUTTONUP or MOUSEBUTTONDOWN event for handling
        """
        rel_pos = (abs_pos[0] - self.surface_abs_pos[0], abs_pos[1] - self.surface_abs_pos[1])
        
        if self.rect.collidepoint(rel_pos):    # Hovering over button
            if self.await_release:   # Only goes back to HOVER state if it's not being pressed
                self._img_ind = self.PRESSED
            else:
                self._img_ind = self.HOVER
            if event is not None:   # Either a mouse-up or mouse-down
                if event.type == pg.MOUSEBUTTONDOWN:
                        self._img_ind = self.PRESSED
                        self.await_release = event.button
                elif event.type == pg.MOUSEBUTTONUP:
                    if self.await_release == event.button:
                        self._img_ind = self.IDLE
                        if event.button in self.funcs:
                            self.funcs[event.button](self)  # Callback function attached to this button
                    self.await_release = None
            return True
        
        # Not hovering over button
        if event is not None:   # If mouse-up or down without being on the button, we reset
            if self.await_release:
                self._img_ind = self.IDLE
                self.await_release = None

        self._img_ind = self.IDLE
        return False

    def draw(self):
        """Blits the button onto it's on_surface
        
        Always call `check_mouse` before this to make sure the correct button state is drawn
        """
        self.on_surface.blit(self.imgs[self._img_ind], self.rect)

    @classmethod
    def fill_none_imgs(cls, imgs):
        """Returns a List of pg.Surface, where all None imgs[i] is replaced with a darker version of imgs[i-1]

        imgs can contain pg.Surface / None
        imgs[0] must be a pg.Surface and not None
        Intended to be used to generate hover/pressed pg.Surface for Buttons
        """
        imgs = list(imgs)
        if imgs[0] is None:
            raise Exception("Idle Button Img not provided")
        for i in range(1, len(imgs)):
            if imgs[i] is None:
                imgs[i] = imgs[i-1].copy()
                imgs[i].fill((20, 20, 20), special_flags=pg.BLEND_SUB)
        return imgs


# Still working on this
# class CellButton(Button):
#     def __init__(self, button_imgs, flag_img, coord, size, gap, grid, grid_abs_pos):
#         self.coord = coord  # (y, x)
#         self.exposed = False
#         self.flagged = False

#         row, col = coord
#         rel_pos = ((size+gap)*col, (size+gap)*row)
#         super().__init__(imgs, offset=rel_pos, funcs={1: self.expose, 3:self.flag}, on_surface=grid, surface_abs_pos=grid_abs_pos)

#     def expose(self):
#         self.exposed = True

#     def flag(self):
#         self.flagged = not self.flagged

#     def draw(self):
#         if self.exposed:
#             self.on_surface.blit(  )
#         else:
#             super.draw()